
.include "m8515def.inc"



.def temp = r16	;регістр тимчасового зберігання
.def dig = r17	;регістр зберігання виведених на індикатор чисел (в hex-форматі)
.def counter = r18		;лічильник циклу в підпрограмі генерації затримки
.def counter1 = r20		;лічильник кількості пройдених станів алгоритму
.def plus = r19		;регістр, який зберігає константу, що додається до маски
.def long_delay_low = r24	;молодший байт лічильника довгої затримки
.def long_delay_high = r25	;старший байт лічильника довгої затримки

;*** Призначення констант ***

;Адреса пари лівих знакомісць статичного семисегментного індикатора
.EQU stat_7seg_left = 0xA000
;Адреса пари правих знакомісць статичного семисегментного індикатора
.EQU stat_7seg_right = 0xB000
;Адреса регістра керування запаленням/гасінням точок/знакомісць статичного семисегментний індикатора
.EQU stat_7seg_control = 0xA004

;***** Початок програми *****

.CSEG		;визначаємо початок сегмента коду
.ORG 0x0000	;визначаємо адресу початку сегмента коду в пам'яті програм

; *** Вектор переривань контролера ***

	rjmp Init; вектор переривання по скиданню
	reti; rjmp EXT_INT0; IRQ0 Handler
	reti; rjmp EXT_INT1; IRQ1 Handler
	reti; rjmp TIM1_CAPT; Timer1 Capture Handler
	reti; rjmp TIM1_COMPA; Timer1 Compare A Handler
	reti; rjmp TIM1_COMPB; Timer1 Compare B Handler
	reti; rjmp TIM1_OVF; Timer1 Overflow Handler
	reti; rjmp TIM0_OVF; Timer0 Overflow Handler
	reti; rjmp SPI_STC; SPI Transfer Complete Handler
	reti; rjmp USART_RXC; USART RX Complete Handler
	reti; rjmp USART_UDRE; UDR0 Empty Handler
	reti; rjmp USART_TXC; USART TX Complete Handler
	reti; rjmp ANA_COMP; Analog Comparator Handler
	reti; rjmp EXT_INT2; IRQ2 Handler
	reti; rjmp TIM0_COMP; Timer0 Compare Handler
	reti; rjmp EE_RDY; EEPROM Ready Handler
	reti; rjmp SPM_RDY; Store Program memory Ready

;*** Початкова ініціалізація контролера ***

Init:

	ldi temp, low (RAMEND)	;ініціалізація вказівника стеку SP
	out SPL, temp
	ldi temp, high (RAMEND)
	out SPH, temp	;встановлення SP на адресу останньої комірки Internal SRAM
	sbi ACSR, 7		;відключення живлення аналогового компаратора

;дозволяємо роботу із зовнішньою пам'яттю (звернення до системного контролеру)
	ldi temp, 0b10000000
	out MCUCR, temp

;Працюємо зі статичним семисегментним індикатором

;Встановлюємо вказівник X на адресу лівої пари знакомісць статичного індикатора
	ldi XL, low (stat_7seg_left)
	ldi XH, high (stat_7seg_left)

;Встановлюємо вказівник Y на адресу правої пари знакомісць статичного індикатора
	ldi YL, low (stat_7seg_right)
	ldi YH, high (stat_7seg_right)

;Встановлюємо вказівник Z на адресу регістра керування статичним індикатором
	ldi ZL, low (stat_7seg_control)
	ldi ZH, high (stat_7seg_control)

;*** Переходимо в нескінченний цикл ***

Infinite_loop:	;нескінченний цикл

	;початкова ініціалізація
	ldi dig, 0x00	;заносимо початкове значення, яке виводиться на індикатор
	ldi plus, 0x11	;заносимо число 0х11, на яке буде збільшуватися початкове
	ldi counter1, 0x10	;ініціалізуємо значення лічильника алгоритму

Loop:; цикл виведення послідовностей символів на індикатор

	st X, dig	;видаємо маску на ліву пару знакомісць індикатора
	st Y, dig	;видаємо маску на праву пару знакомісць індикатора

	ldi temp, 0x00	;вимикаємо всі точки і запалюємо всі знакомісця
	st Z, temp		;записуємо цю маску в регістр керування індикатором

	rcall long_delay	;викликаємо затримку приблизно на 2 с

	ldi temp, 0x0F	;вимикаємо всі точки і гасимо всі знакомісця
	st Z, temp		;записуємо цю маску в регістр керування індикатором

	rcall long_delay	;викликаємо затримку приблизно на 2 с

	add dig, plus	;додаємо до початкового значення маски число 11h
	dec counter1	;зменшуємо значення лічильника кількості ітерацій на 1

	breq Infinite_loop	;перехід здійниться, якщо лічильник дорівнює 0
	rjmp Loop			;стрибаємо на виконання наступної ітерації алгоритму

;*** Підпрограма довгої затримки ***

long_delay:
;* Якщо в регістрову пару завантажити число 18432 (4800h), то затримка буде близько 2 секунд

;* Приблизна формула розрахунку коефіцієнта при кварці у 7.3728 МГц така:
;* 800 x коефіцієнт затримки / (7.3728 * 1 000 000) = необхідний час в [с]

	ldi long_delay_low, 0x00;завантаження в регістрову пару коефіцієнта затримки
	ldi long_delay_high, 0x48	;(4800h), це буде затримка на 2 с

long_loop:	;тіло циклу займає 796 + 2 + 2 = 800 тактів
	rcall short_delay		;коротка затримка
	sbiw long_delay_high: long_delay_low, 0b00000001	;віднімання з пари числа 1 (декремент довгого лічильника)
	brne long_loop	;якщо не 0, повторити цикл
	ret			;повернення в основну програму

;*** Підпрограма короткої затримки (потрібна для генерації довгих затримок) ***
short_delay:	;вся підпрограма займає рівно 796 тактів разом з rcall і ret

	nop
	ldi counter, 0xC5	;лічильник циклу
short_loop:
	nop
	dec counter
	brne short_loop	;команда розгалуження по прапорцю нуля (зациклення)
	ret			;повернення в основну програму	
.EXIT				;кінець програми
